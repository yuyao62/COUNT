pill-model/
  model.json
  *.bin
<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>è—¥ç²’è¨ˆæ•¸ WebApp (AIç‰ˆ)</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 14px; background:#fafafa; }
    .wrap { max-width: 720px; margin: 0 auto; }
    h1 { text-align: center; margin: 8px 0 14px; font-size: 24px; }
    .panel { background:#fff; border: 1px solid #e5e7eb; border-radius: 14px; padding: 12px; margin: 12px 0; }
    .stage { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    @media (max-width: 720px) { .stage { grid-template-columns: 1fr; } }
    video, canvas { width: 100%; border-radius: 12px; background: #111827; }
    .row { display:flex; gap:10px; flex-wrap: wrap; justify-content:center; margin-top: 10px; }
    button {
      font-size: 16px; padding: 10px 14px; border-radius: 12px;
      border: 1px solid #d1d5db; background:#fff; cursor:pointer;
    }
    button.primary { border-color:#1d4ed8; color:#1d4ed8; font-weight:700; }
    button:disabled { opacity:.45; cursor:not-allowed; }
    #count { text-align:center; font-size: 22px; font-weight: 800; color:#1d4ed8; margin-top: 12px; }
    .kv { display:grid; grid-template-columns: 110px 1fr; gap: 8px 10px; align-items:center; }
    input[type="number"]{ width: 110px; padding: 8px; border-radius: 10px; border: 1px solid #d1d5db; }
    select{ padding: 8px; border-radius: 10px; border: 1px solid #d1d5db; }
    code { background:#f3f4f6; padding: 3px 8px; border-radius: 8px; }
    .small { font-size: 12px; color:#6b7280; line-height:1.45; }
    #log { white-space: pre-wrap; background:#0b1020; color:#dbeafe; padding: 10px; border-radius: 12px; max-height: 240px; overflow:auto; font-size: 12px; }
    .badge { display:inline-block; padding: 4px 10px; border-radius: 999px; background:#eef2ff; color:#3730a3; font-weight:700; }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>ğŸ’Š è—¥ç²’è¨ˆæ•¸ WebApp (AIç‰ˆ)</h1>

    <div class="panel">
      <div class="stage">
        <div>
          <div class="small"><span class="badge">å³æ™‚ç›¸æ©Ÿ</span></div>
          <!-- iOS å¿…å‚™ï¼šmuted + playsinlineï¼Œä¸¦ä¸”ç”¨ JS æ‰‹å‹• video.play() -->
          <video id="video" autoplay playsinline muted></video>
        </div>
        <div>
          <div class="small"><span class="badge">æƒæçµæœ</span></div>
          <canvas id="canvas"></canvas>
        </div>
      </div>

      <div class="row">
        <button id="startBtn" class="primary">ğŸ¥ å•Ÿå‹•ç›¸æ©Ÿ</button>
        <button id="scanBtn" class="primary" disabled>ğŸ“¸ æƒæä¸¦è¨ˆæ•¸</button>
        <button id="stopBtn" disabled>â¹ï¸ åœæ­¢ç›¸æ©Ÿ</button>
      </div>

      <div id="count">åµæ¸¬åˆ°è—¥ç²’æ•¸é‡ï¼š0</div>
    </div>

    <div class="panel">
      <div class="kv">
        <div>æ¨¡å‹è·¯å¾‘</div>
        <div><code id="modelPath">pill-model/model.json</code></div>

        <div>ä¿¡å¿ƒé–¾å€¼</div>
        <div>
          <input id="thr" type="number" min="0" max="1" step="0.05" value="0.50" />
          <span class="small">ï¼ˆ0~1ï¼Œè¶Šé«˜è¶Šåš´æ ¼ï¼›å°ç‰©ä»¶å»ºè­° 0.2~0.4ï¼‰</span>
        </div>

        <div>æ¨è«–å°ºå¯¸</div>
        <div>
          <select id="inferSize">
            <option value="320">320</option>
            <option value="416">416</option>
            <option value="512" selected>512</option>
            <option value="640">640</option>
          </select>
          <span class="small">ï¼ˆå…ˆ resize å†é€æ¨¡å‹ï¼›512/640 é€šå¸¸è¼ƒæº–è¼ƒæ…¢ï¼‰</span>
        </div>

        <div>ç‹€æ…‹</div>
        <div id="status" class="small">å°šæœªå•Ÿå‹•</div>
      </div>
    </div>

    <div class="panel">
      <div class="small">
        å¸¸è¦‹é™åˆ¶ï¼šç›¸æ©Ÿéœ€è¦ <b>HTTPS</b> æˆ– <b>localhost</b>ï¼›æ¨¡å‹å¿…é ˆæ˜¯ã€Œç‰©ä»¶åµæ¸¬ã€é¡å‹ï¼ˆèƒ½è¼¸å‡º boxes/scoresï¼‰ã€‚
        è‹¥åµæ¸¬ä¸€ç›´æ˜¯ 0ï¼Œè«‹çœ‹ä¸‹é¢ log çš„ outputs åç¨±/shape ä¾†å°æ‡‰æ¨¡å‹è¼¸å‡ºã€‚
      </div>
      <div id="log"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>

  <script>
    // ===== DOM =====
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const scanBtn = document.getElementById('scanBtn');
    const stopBtn = document.getElementById('stopBtn');
    const countDiv = document.getElementById('count');
    const statusEl = document.getElementById('status');
    const thrEl = document.getElementById('thr');
    const inferSizeEl = document.getElementById('inferSize');
    const logEl = document.getElementById('log');
    const modelPathEl = document.getElementById('modelPath');

    // ===== ç‹€æ…‹ =====
    let stream = null;
    let model = null;
    let modelLoaded = false;

    function log(...args) {
      const msg = args.map(x => (typeof x === 'string' ? x : JSON.stringify(x, null, 2))).join(' ');
      console.log(...args);
      logEl.textContent = msg + "\n" + logEl.textContent;
    }
    function setStatus(s) { statusEl.textContent = s; }

    function isSecureOK() {
      const isLocalhost = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
      return location.protocol === 'https:' || isLocalhost;
    }

    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    function drawFrame() {
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    }
    function drawBox(box, score) {
      // box: [ymin, xmin, ymax, xmax] normalized 0~1
      const [ymin, xmin, ymax, xmax] = box;
      const x = xmin * canvas.width;
      const y = ymin * canvas.height;
      const w = (xmax - xmin) * canvas.width;
      const h = (ymax - ymin) * canvas.height;

      ctx.strokeStyle = "red";
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, w, h);

      ctx.fillStyle = "red";
      ctx.font = "16px Arial";
      ctx.fillText((score * 100).toFixed(1) + "%", x + 4, Math.max(18, y + 18));
    }

    function threshold() {
      const v = Number(thrEl.value);
      return Number.isFinite(v) ? Math.min(1, Math.max(0, v)) : 0.5;
    }
    function inferSize() {
      const v = Number(inferSizeEl.value);
      return Number.isFinite(v) ? v : 512;
    }

    async function waitVideoReady() {
      await new Promise(resolve => {
        if (video.readyState >= 2 && video.videoWidth > 0) return resolve();
        video.onloadedmetadata = () => resolve();
      });
    }

    // ===== ç›¸æ©Ÿï¼ˆiOS å¿…éï¼‰=====
    async function startCamera() {
      if (!navigator.mediaDevices?.getUserMedia) {
        throw new Error("æ­¤ç€è¦½å™¨ä¸æ”¯æ´ getUserMedia()");
      }
      if (!isSecureOK()) {
        throw new Error("ç›¸æ©Ÿéœ€è¦ HTTPS æˆ– localhostã€‚ä½ ç›®å‰æ˜¯ï¼š" + location.href);
      }

      setStatus("å•Ÿå‹•ç›¸æ©Ÿä¸­â€¦");

      // å…ˆåœæ‰èˆŠçš„
      stopCamera();

      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: "environment" } },
          audio: false
        });

        video.srcObject = stream;

        // ç­‰ metadata å‡ºä¾†
        await waitVideoReady();

        // â­ iOS é—œéµï¼šå¿…é ˆæ‰‹å‹• play
        await video.play();

        // è¨­å®š canvas å°ºå¯¸
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;

        clearCanvas();
        drawFrame();

        setStatus(`ç›¸æ©Ÿå·²å•Ÿå‹•ï¼š${canvas.width} x ${canvas.height}`);

        stopBtn.disabled = false;
        scanBtn.disabled = !modelLoaded;

      } catch (e) {
        // å¸¸è¦‹ï¼šNotAllowedError / NotFoundError / NotReadableError / SecurityError
        log("âŒ Camera error:", { name: e.name, message: e.message });
        setStatus("ç›¸æ©Ÿå•Ÿå‹•å¤±æ•—");
        throw e;
      }
    }

    function stopCamera() {
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      video.srcObject = null;
      stopBtn.disabled = true;
      scanBtn.disabled = true;
    }

    // ===== æ¨¡å‹ =====
    async function loadModel() {
      setStatus("è¼‰å…¥æ¨¡å‹ä¸­â€¦");
      const path = modelPathEl.textContent.trim();

      model = await tf.loadGraphModel(path);
      modelLoaded = true;

      const ins = model.inputs.map(i => ({ name: i.name, shape: i.shape, dtype: i.dtype }));
      const outs = model.outputs.map(o => ({ name: o.name, shape: o.shape, dtype: o.dtype }));
      log("âœ… æ¨¡å‹è¼‰å…¥å®Œæˆ");
      log("inputs:", ins);
      log("outputs:", outs);

      setStatus("æ¨¡å‹è¼‰å…¥å®Œæˆ");
      scanBtn.disabled = !stream; // æœ‰ç›¸æ©Ÿæ‰é–‹æ”¾æƒæ
    }

    function disposeOut(out) {
      if (Array.isArray(out)) out.forEach(t => t?.dispose?.());
      else Object.values(out).forEach(t => t?.dispose?.());
    }

    // æŠ½å– boxes/scores/numï¼ˆç›¸å®¹ TF2 OD API / TFLite postprocess / fallbackï¼‰
    function pickOutputs(out) {
      let boxesT = null, scoresT = null, numT = null;

      if (Array.isArray(out)) {
        boxesT = out[0] || null;
        scoresT = out[1] || null;
        numT = out[3] || null;
        return { boxesT, scoresT, numT };
      }

      boxesT  = out['detection_boxes']  || out['TFLite_Detection_PostProcess']    || null;
      scoresT = out['detection_scores'] || out['TFLite_Detection_PostProcess:1']  || null;
      numT    = out['num_detections']   || out['TFLite_Detection_PostProcess:3']  || null;

      if (!boxesT || !scoresT) {
        const keys = Object.keys(out);
        log("â„¹ï¸ output keys:", keys);
        for (const k of keys) {
          const t = out[k];
          const s = t?.shape || [];
          if (!boxesT && s.length === 3 && s[s.length - 1] === 4) boxesT = t; // [1,N,4]
          if (!scoresT && s.length === 2) scoresT = t; // [1,N]
        }
      }

      return { boxesT, scoresT, numT };
    }

    async function detectOnce() {
      if (!modelLoaded) throw new Error("æ¨¡å‹å°šæœªè¼‰å…¥");
      if (!stream) throw new Error("ç›¸æ©Ÿå°šæœªå•Ÿå‹•");

      // ç¢ºä¿å°ºå¯¸æ­£ç¢º
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;

      clearCanvas();
      drawFrame();

      const thr = threshold();
      const size = inferSize();

      setStatus(`æ¨è«–ä¸­â€¦ thr=${thr} size=${size}`);

      const result = await tf.tidy(async () => {
        // å¾ canvas æ“·å– -> resize -> normalize -> [1,H,W,3]
        const img = tf.browser.fromPixels(canvas).toFloat();
        const resized = tf.image.resizeBilinear(img, [size, size], true);
        const input = resized.div(255).expandDims(0);

        const out = await model.executeAsync(input);
        const { boxesT, scoresT, numT } = pickOutputs(out);

        if (!boxesT || !scoresT) {
          // å° shapes è®“ä½  debug
          if (Array.isArray(out)) {
            log("âŒ ç„¡æ³•æ¨æ–· boxes/scoresã€‚Array outputs shapes:");
            out.forEach((t, i) => log(`  [${i}] shape=`, t.shape));
          } else {
            log("âŒ ç„¡æ³•æ¨æ–· boxes/scoresã€‚Named outputs shapes:");
            Object.entries(out).forEach(([k, t]) => log(`  ${k} shape=`, t.shape));
          }
          disposeOut(out);
          throw new Error("æ¨¡å‹è¼¸å‡ºä¸æ˜¯å¸¸è¦‹åµæ¸¬æ ¼å¼ï¼Œè«‹çœ‹ log çš„ outputs/keys/shape ä¾†å°æ‡‰ã€‚");
        }

        const boxesArr = await boxesT.array();
        const scoresArr = await scoresT.array();
        const numArr = numT ? await numT.array() : null;

        disposeOut(out);

        const boxes = (Array.isArray(boxesArr[0]) && Array.isArray(boxesArr[0][0])) ? boxesArr[0] : boxesArr;
        const scores = (Array.isArray(scoresArr[0])) ? scoresArr[0] : scoresArr;
        const num = (numArr && Array.isArray(numArr)) ? Number(numArr[0]) : null;

        return { boxes, scores, num, thr };
      });

      // ç•«æ¡†ï¼ˆå›åˆ°åŸå°ºå¯¸ï¼‰
      clearCanvas();
      drawFrame();

      const { boxes, scores, num, thr } = result;
      const N = num ? Math.min(num, boxes.length, scores.length) : Math.min(boxes.length, scores.length);

      let pillCount = 0;
      for (let i = 0; i < N; i++) {
        const sc = scores[i];
        if (sc >= thr) {
          pillCount++;
          drawBox(boxes[i], sc);
        }
      }

      countDiv.textContent = "åµæ¸¬åˆ°è—¥ç²’æ•¸é‡ï¼š" + pillCount;
      setStatus(`å®Œæˆ âœ… åµæ¸¬ ${pillCount} é¡†ï¼ˆå€™é¸ ${N}ï¼‰`);
    }

    // ===== äº‹ä»¶ =====
    startBtn.addEventListener('click', async () => {
      startBtn.disabled = true;
      try {
        await startCamera();
        // ç¬¬ä¸€æ¬¡å•Ÿå‹•æ™‚è¼‰æ¨¡å‹ï¼ˆä¹Ÿå¯æ”¹æˆé é¢ä¸€é–‹å§‹å°±è¼‰ï¼‰
        if (!modelLoaded) await loadModel();
      } catch (e) {
        alert("ç›¸æ©Ÿå•Ÿå‹•å¤±æ•—ï¼š\n" + e.name + "\n" + e.message);
      } finally {
        startBtn.disabled = false;
      }
    });

    stopBtn.addEventListener('click', () => {
      stopCamera();
      setStatus("ç›¸æ©Ÿå·²åœæ­¢");
    });

    scanBtn.addEventListener('click', async () => {
      scanBtn.disabled = true;
      try {
        await detectOnce();
      } catch (e) {
        log("âŒ Detect error:", { name: e.name, message: e.message });
        alert("æ¨è«–å¤±æ•—ï¼š\n" + e.message);
        setStatus("æ¨è«–å¤±æ•—");
      } finally {
        scanBtn.disabled = false;
      }
    });

    // ===== æç¤º =====
    (function init() {
      log("æç¤ºï¼šç›¸æ©Ÿéœ€ HTTPS/localhostï¼›iOS éœ€è¦ muted + playsinline + æ‰‹å‹• video.play()");
      if (!isSecureOK()) log("âš ï¸ ç›®å‰ä¸æ˜¯ HTTPS/localhostï¼ŒiPhone å¯èƒ½ç„¡æ³•å•Ÿå‹•ç›¸æ©Ÿã€‚");
      setStatus("å°šæœªå•Ÿå‹•");
    })();
  </script>
</body>
</html>
