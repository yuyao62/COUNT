<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>è—¥ç²’è¨ˆæ•¸ WebApp (AIç‰ˆ)</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; margin: 0; padding: 12px; }
    .wrap { max-width: 520px; margin: 0 auto; }
    h1 { margin: 8px 0 12px; font-size: 22px; }
    .panel { border: 1px solid #ddd; border-radius: 12px; padding: 10px; margin: 10px 0; }
    video, canvas { width: 100%; max-width: 480px; border-radius: 10px; }
    #count { font-size: 18px; color: #0b3d91; margin-top: 10px; font-weight: 700; }
    button {
      font-size: 16px; padding: 10px 14px; margin: 8px 6px;
      border-radius: 10px; border: 1px solid #ccc; background: #fff; cursor: pointer;
    }
    button.primary { border-color: #0b3d91; }
    button:disabled { opacity: .45; cursor: not-allowed; }
    .row { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; }
    .small { font-size: 12px; color: #666; text-align: left; line-height: 1.4; }
    .kv { display: grid; grid-template-columns: 110px 1fr; gap: 6px 10px; text-align: left; }
    input[type="number"]{ width: 90px; padding: 6px; border-radius: 8px; border: 1px solid #ccc; }
    select{ padding: 6px; border-radius: 8px; border: 1px solid #ccc; }
    code { background: #f6f6f6; padding: 2px 6px; border-radius: 6px; }
    #log { white-space: pre-wrap; text-align: left; background: #0b1020; color: #d7e1ff; padding: 10px; border-radius: 10px; font-size: 12px; max-height: 220px; overflow: auto; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>ğŸ’Š è—¥ç²’è¨ˆæ•¸ WebApp (AIç‰ˆ)</h1>

    <div class="panel">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="canvas"></canvas>

      <div class="row">
        <button id="startBtn" class="primary">ğŸ¥ å•Ÿå‹•ç›¸æ©Ÿ</button>
        <button id="scanBtn" class="primary" disabled>ğŸ“¸ æƒæä¸¦è¨ˆæ•¸</button>
        <button id="stopBtn" disabled>â¹ï¸ åœæ­¢ç›¸æ©Ÿ</button>
      </div>

      <div id="count">åµæ¸¬åˆ°è—¥ç²’æ•¸é‡ï¼š0</div>
    </div>

    <div class="panel">
      <div class="kv">
        <div>æ¨¡å‹è·¯å¾‘</div>
        <div><code>pill-model/model.json</code></div>

        <div>ä¿¡å¿ƒé–¾å€¼</div>
        <div>
          <input id="thr" type="number" min="0" max="1" step="0.05" value="0.50" />
          <span class="small">ï¼ˆ0~1ï¼Œè¶Šé«˜è¶Šåš´æ ¼ï¼‰</span>
        </div>

        <div>æ¨è«–å°ºå¯¸</div>
        <div>
          <select id="inferSize">
            <option value="320">320</option>
            <option value="416">416</option>
            <option value="512" selected>512</option>
            <option value="640">640</option>
          </select>
          <span class="small">ï¼ˆæœƒå…ˆ resize å†ä¸Ÿæ¨¡å‹ï¼Œé€šå¸¸ 512/640 è¼ƒæº–ä½†è¼ƒæ…¢ï¼‰</span>
        </div>

        <div>ç‹€æ…‹</div>
        <div id="status" class="small">å°šæœªå•Ÿå‹•</div>
      </div>
    </div>

    <div class="panel">
      <div class="small">
        å¸¸è¦‹é™åˆ¶ï¼šç›¸æ©Ÿéœ€è¦ <b>HTTPS æˆ– localhost</b>ï¼›æ¨¡å‹å¿…é ˆæ˜¯ã€Œç‰©ä»¶åµæ¸¬ã€é¡å‹ï¼ˆèƒ½è¼¸å‡º boxes/scoresï¼‰ã€‚
        è‹¥ä½ ä¸ç¢ºå®šæ¨¡å‹è¼¸å‡ºï¼ŒæŒ‰ä¸€æ¬¡æƒæå¾Œåˆ°ä¸‹é¢ log çœ‹ outputs å½¢ç‹€/åç¨±ã€‚
      </div>
      <div id="log"></div>
    </div>
  </div>

  <!-- TensorFlow.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>

  <script>
    // ===== DOM =====
    const video   = document.getElementById('video');
    const canvas  = document.getElementById('canvas');
    const ctx     = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const scanBtn  = document.getElementById('scanBtn');
    const stopBtn  = document.getElementById('stopBtn');
    const countDiv = document.getElementById('count');
    const statusEl = document.getElementById('status');
    const thrEl    = document.getElementById('thr');
    const inferSizeEl = document.getElementById('inferSize');
    const logEl    = document.getElementById('log');

    // ===== ç‹€æ…‹ =====
    let stream = null;
    let model = null;
    let modelLoaded = false;

    function log(...args) {
      const msg = args.map(x => (typeof x === 'string' ? x : JSON.stringify(x, null, 2))).join(' ');
      console.log(...args);
      logEl.textContent = (msg + "\n") + logEl.textContent;
    }

    function setStatus(s) { statusEl.textContent = s; }

    function isSecureOK() {
      // ç›¸æ©Ÿåœ¨å¤§å¤šæ•¸ç€è¦½å™¨è¦æ±‚ https æˆ– localhost
      const isLocalhost = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
      return location.protocol === 'https:' || isLocalhost;
    }

    function clearOverlay() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function drawFrameFromVideo() {
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    }

    function drawBox(box, score) {
      // box: [ymin, xmin, ymax, xmax] (normalized 0~1)
      const [ymin, xmin, ymax, xmax] = box;
      const x = xmin * canvas.width;
      const y = ymin * canvas.height;
      const w = (xmax - xmin) * canvas.width;
      const h = (ymax - ymin) * canvas.height;

      ctx.strokeStyle = "red";
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, w, h);

      ctx.fillStyle = "red";
      ctx.font = "16px Arial";
      const label = (score * 100).toFixed(1) + "%";
      ctx.fillText(label, x + 4, Math.max(18, y + 18));
    }

    async function waitVideoReady() {
      await new Promise(resolve => {
        if (video.readyState >= 2 && video.videoWidth > 0) return resolve();
        video.onloadedmetadata = () => resolve();
      });
    }

    // ===== ç›¸æ©Ÿ =====
    async function startCamera() {
      if (!navigator.mediaDevices?.getUserMedia) {
        throw new Error("æ­¤ç€è¦½å™¨ä¸æ”¯æ´ getUserMedia()");
      }
      if (!isSecureOK()) {
        throw new Error("ç›¸æ©Ÿéœ€è¦ HTTPS æˆ– localhostã€‚è«‹ç”¨ https éƒ¨ç½²æˆ–åœ¨æœ¬æ©Ÿ localhost é–‹ã€‚");
      }

      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal: "environment" } },
        audio: false
      });
      video.srcObject = stream;
      await waitVideoReady();

      // è¨­å®š canvas å°ºå¯¸è·Ÿè‘— video
      canvas.width  = video.videoWidth;
      canvas.height = video.videoHeight;

      clearOverlay();
      drawFrameFromVideo();

      setStatus(`ç›¸æ©Ÿå·²å•Ÿå‹•ï¼š${canvas.width}x${canvas.height}`);
      scanBtn.disabled = !modelLoaded;
      stopBtn.disabled = false;
    }

    function stopCamera() {
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      video.srcObject = null;
      setStatus("ç›¸æ©Ÿå·²åœæ­¢");
      scanBtn.disabled = true;
      stopBtn.disabled = true;
    }

    // ===== æ¨¡å‹ =====
    async function loadModel() {
      setStatus("è¼‰å…¥æ¨¡å‹ä¸­â€¦");
      // ä½ æ¨¡å‹çš„è·¯å¾‘ï¼ˆåŒç¶²åŸŸï¼‰
      const path = 'pill-model/model.json';

      model = await tf.loadGraphModel(path);
      modelLoaded = true;

      // å°å‡º inputs/outputs ä»¥ä¾¿å°æ‡‰
      const ins = model.inputs.map(i => ({ name: i.name, shape: i.shape, dtype: i.dtype }));
      const outs = model.outputs.map(o => ({ name: o.name, shape: o.shape, dtype: o.dtype }));
      log("âœ… æ¨¡å‹è¼‰å…¥å®Œæˆ");
      log("inputs:", ins);
      log("outputs:", outs);

      setStatus("æ¨¡å‹è¼‰å…¥å®Œæˆ");
      scanBtn.disabled = !stream; // è¦æœ‰ç›¸æ©Ÿæ‰å¯æƒæ
    }

    function getThreshold() {
      const v = Number(thrEl.value);
      if (Number.isFinite(v)) return Math.min(1, Math.max(0, v));
      return 0.5;
    }

    function getInferSize() {
      const v = Number(inferSizeEl.value);
      return Number.isFinite(v) ? v : 512;
    }

    // ===== å¾è¼¸å‡ºæŠ½ boxes/scores/num =====
    function pickOutputs(out) {
      // out å¯èƒ½æ˜¯ Array<Tensor> æˆ– NamedTensorMap
      let boxesT = null, scoresT = null, numT = null;

      if (Array.isArray(out)) {
        // å¸¸è¦‹ï¼šout[0]=boxes, out[1]=scores, out[2]=classes, out[3]=num
        boxesT = out[0] || null;
        scoresT = out[1] || null;
        numT = out[3] || null;
        return { boxesT, scoresT, numT };
      }

      // å¸¸è¦‹ TF2 OD API
      boxesT  = out['detection_boxes']  || out['TFLite_Detection_PostProcess']    || null;
      scoresT = out['detection_scores'] || out['TFLite_Detection_PostProcess:1']  || null;
      numT    = out['num_detections']   || out['TFLite_Detection_PostProcess:3']  || null;

      // fallbackï¼šç”¨ shape çŒœï¼ˆ[1,N,4] ç•¶ boxesï¼Œ[1,N] ç•¶ scoresï¼‰
      if (!boxesT || !scoresT) {
        const keys = Object.keys(out);
        log("â„¹ï¸ output keys:", keys);

        for (const k of keys) {
          const t = out[k];
          const s = t?.shape || [];
          if (!boxesT && s.length === 3 && s[s.length - 1] === 4) boxesT = t;
          if (!scoresT && s.length === 2) scoresT = t;
        }
      }

      return { boxesT, scoresT, numT };
    }

    function disposeOut(out) {
      if (Array.isArray(out)) out.forEach(t => t?.dispose?.());
      else Object.values(out).forEach(t => t?.dispose?.());
    }

    // ===== æ¨è«– =====
    async function detectOnce() {
      if (!modelLoaded) throw new Error("æ¨¡å‹å°šæœªè¼‰å…¥");
      if (!stream) throw new Error("ç›¸æ©Ÿå°šæœªå•Ÿå‹•");

      // ä»¥ç›®å‰ video ç•«é¢ç‚ºåŸºæº–
      canvas.width  = video.videoWidth;
      canvas.height = video.videoHeight;
      clearOverlay();
      drawFrameFromVideo();

      const threshold = getThreshold();
      const inferSize = getInferSize();

      setStatus(`æ¨è«–ä¸­â€¦ threshold=${threshold} size=${inferSize}`);

      // ç”¨ tf.tidy æ§åˆ¶è¨˜æ†¶é«”
      const result = await tf.tidy(async () => {
        // å¾ canvas å–åƒç´  â†’ resize åˆ°æ¨¡å‹æ¨è«–å°ºå¯¸ â†’ normalize
        const img = tf.browser.fromPixels(canvas).toFloat();
        const resized = tf.image.resizeBilinear(img, [inferSize, inferSize], true);
        const input = resized.div(255).expandDims(0); // [1, H, W, 3]

        const out = await model.executeAsync(input);
        const { boxesT, scoresT, numT } = pickOutputs(out);

        if (!boxesT || !scoresT) {
          // å°å‡ºæ‰€æœ‰ shape å¹«ä½  debug
          if (Array.isArray(out)) {
            log("âŒ ç„¡æ³•æ¨æ–· boxes/scoresã€‚Array outputs shapes:");
            out.forEach((t, i) => log(`  [${i}] shape=`, t.shape));
          } else {
            log("âŒ ç„¡æ³•æ¨æ–· boxes/scoresã€‚Named outputs shapes:");
            Object.entries(out).forEach(([k, t]) => log(`  ${k} shape=`, t.shape));
          }
          disposeOut(out);
          throw new Error("æ¨¡å‹è¼¸å‡ºä¸æ˜¯å¸¸è¦‹åµæ¸¬æ ¼å¼ï¼Œè«‹çœ‹ log çš„ outputs/keys/shape ä¾†å°æ‡‰ã€‚");
        }

        const boxesArr = await boxesT.array();   // å¯èƒ½ [1,N,4] æˆ– [N,4]
        const scoresArr = await scoresT.array(); // å¯èƒ½ [1,N] æˆ– [N]
        const numArr = numT ? await numT.array() : null;

        disposeOut(out);

        // å» batch ç¶­åº¦
        const boxes = (Array.isArray(boxesArr[0]) && Array.isArray(boxesArr[0][0])) ? boxesArr[0] : boxesArr;
        const scores = (Array.isArray(scoresArr[0])) ? scoresArr[0] : scoresArr;
        const num = (numArr && Array.isArray(numArr)) ? Number(numArr[0]) : null;

        return { boxes, scores, num, threshold };
      });

      // é‡æ–°ç•«åº•åœ–ï¼ˆå› ç‚º tidy çµæŸå¾Œæˆ‘å€‘è¦åœ¨åŸå°ºå¯¸ç•«æ¡†ï¼‰
      clearOverlay();
      drawFrameFromVideo();

      const { boxes, scores, num, threshold } = result;
      const N = num ? Math.min(num, scores.length, boxes.length) : Math.min(scores.length, boxes.length);

      let pillCount = 0;
      for (let i = 0; i < N; i++) {
        const sc = scores[i];
        if (sc >= threshold) {
          pillCount++;
          drawBox(boxes[i], sc);
        }
      }

      countDiv.textContent = "åµæ¸¬åˆ°è—¥ç²’æ•¸é‡ï¼š" + pillCount;
      setStatus(`å®Œæˆ âœ… åµæ¸¬ ${pillCount} é¡†ï¼ˆå€™é¸ ${N}ï¼‰`);
    }

    // ===== äº‹ä»¶ =====
    startBtn.addEventListener('click', async () => {
      try {
        startBtn.disabled = true;
        setStatus("å•Ÿå‹•ä¸­â€¦");
        await startCamera();

        // ç¬¬ä¸€æ¬¡å•Ÿå‹•æ™‚è¼‰å…¥æ¨¡å‹ï¼ˆä¹Ÿå¯æ”¹æˆé é¢ä¸€é–‹å§‹å°±è¼‰ï¼‰
        if (!modelLoaded) await loadModel();

        startBtn.disabled = false;
      } catch (e) {
        startBtn.disabled = false;
        log("âŒ", e.message);
        alert(e.message);
        setStatus("å•Ÿå‹•å¤±æ•—");
      }
    });

    stopBtn.addEventListener('click', () => {
      stopCamera();
    });

    scanBtn.addEventListener('click', async () => {
      scanBtn.disabled = true;
      try {
        await detectOnce();
      } catch (e) {
        log("âŒ", e.message);
        alert("æ¨è«–å¤±æ•—ï¼š" + e.message);
        setStatus("æ¨è«–å¤±æ•—");
      } finally {
        scanBtn.disabled = false;
      }
    });

    // é é¢è¼‰å…¥æç¤º
    (function initHint() {
      log("æç¤ºï¼šç›¸æ©Ÿéœ€ HTTPS/localhostï¼›æ¨¡å‹éœ€æ”¾åœ¨ pill-model/model.json");
      if (!isSecureOK()) {
        log("âš ï¸ ç›®å‰ä¸æ˜¯ HTTPS/localhostï¼Œå•Ÿå‹•ç›¸æ©Ÿå¯èƒ½æœƒå¤±æ•—ã€‚");
      }
      setStatus("è«‹æŒ‰ã€Œå•Ÿå‹•ç›¸æ©Ÿã€");
    })();
  </script>
</body>
</html>
